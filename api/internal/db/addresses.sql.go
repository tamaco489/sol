// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: addresses.sql

package db

import (
	"context"
)

const findAddressByUserID = `-- name: FindAddressByUserID :one
SELECT
    id,
    user_id,
    zip_code,
    prefecture,
    city,
    street
FROM addresses
WHERE user_id = ?
`

type FindAddressByUserIDRow struct {
	ID         int64
	UserID     int64
	ZipCode    string
	Prefecture string
	City       string
	Street     string
}

func (q *Queries) FindAddressByUserID(ctx context.Context, userID int64) (FindAddressByUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, findAddressByUserID, userID)
	var i FindAddressByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ZipCode,
		&i.Prefecture,
		&i.City,
		&i.Street,
	)
	return i, err
}

const insertAddress = `-- name: InsertAddress :exec
INSERT INTO addresses (
  user_id,
  zip_code,
  prefecture,
  city,
  street
) VALUES (?, ?, ?, ?, ?)
`

type InsertAddressParams struct {
	UserID     int64
	ZipCode    string
	Prefecture string
	City       string
	Street     string
}

func (q *Queries) InsertAddress(ctx context.Context, arg InsertAddressParams) error {
	_, err := q.db.ExecContext(ctx, insertAddress,
		arg.UserID,
		arg.ZipCode,
		arg.Prefecture,
		arg.City,
		arg.Street,
	)
	return err
}

const isAddressExistsByUserID = `-- name: IsAddressExistsByUserID :one
SELECT EXISTS(SELECT 1 FROM addresses WHERE user_id = ?) as is_exists
`

func (q *Queries) IsAddressExistsByUserID(ctx context.Context, userID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, isAddressExistsByUserID, userID)
	var is_exists bool
	err := row.Scan(&is_exists)
	return is_exists, err
}
